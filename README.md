è¿™æ˜¯æ–¯å¦ç¦106ç³»åˆ—çš„C++è¿›é˜¶è¯¾ç¨‹ï¼Œå¯ä»¥è¯´æ˜¯ç´§è·Ÿæ—¶ä»£ï¼Œä»æ¶µç›–ä»C++11åˆ°C++20å‡ ä¹å…¨éƒ¨çš„çŸ¥è¯†ç‚¹ï¼Œå®éªŒä¹Ÿä¸ç®—éš¾ï¼ŒåŸºæœ¬éƒ½åœ¨æ•™ä½ å¦‚ä½•ä½¿ç”¨è¿™äº›æ–°é­”æ³•ã€‚
æ¯”è¾ƒä¸é”™çš„ä¸€é—¨è¯¾ï¼Œæ¨èæŒ‡æ•°ğŸŒŸğŸŒŸğŸŒŸ
è€—æ—¶:2020.12.18-2020.12.28

### Lecture 10: Classes I

#### File Layout

![](./images/1.png)


#### Type Aliases
```C++
using newType = oldType
```

#### Using Member Types

* Before class specifier, use typename.
```C++
template <typename T>
typename vector<T>::iterator vector<T>::insert(iterator pos,
int value) {
}
```

### Lecture 11: Const correctness

* If a function should be able to be called on a const object, it should be designated as const.


#### Summary of `const`
* const reference = a reference that cannot be used to modify the object that is being referenced.
* const method = a method of a class that can't change any class
variables and can only call other const methods.
* const object = an object declared as const that can only call its const methods.

>>Note: compiler will prefer the
non-const version if itâ€™s not clear
which one is being invoked

#### `const_iterator`
`const_iterator` points to const objects,But the const_iterator object itself is not const,so we can perform `++` on a const_iterator but we cannot write to a const_iterator(`*iter=3`). A const iterator is a const object, cannot be reassigned but can write.


### Lecture 12: Operators

#### Member Functions
Member Function is a function with `this` as the left-hand side of expression. But non-member will not.


### Lecture 13: Special Member Functions

#### Special member functions
> Special member functions are (usually) automatically generated by the compiler

* default construction
* copy construction
* copy assignment
* destruction

```C++
 vector<int> vec1; //default construction
 vector<int> vec2(3);//Not a special member function
 vector<int> vec3{3};//uses initializer_list
 vector<int> vec4();//function declaration
 vector<int> vec5(vec2);//copy construction
 vector<int> vec6{};//default construction
 vector<int> vec7{vec3 + vec4};//copy construction
 vector<int> vec8 = vec4;//copy construction
 vec8 = vec2;//copy assignment
```

![](./images/2.png)


### Lecture 14ï¼šMove Semantics
A lvalue has an address (can do &), and a rvalue does not

![](./images/3.png)

`std::move` just forces anything to become a rvalue



```C++
template <typename T>
void vector<T>::push_back(const T& element) {
elems[_size++] = element; // equals â†’ copy }
template <typename T>
void vector<T>::push_back(T&& element) {
elems[_size++] = std::move(element); // move! }
```

```C++
template <typename T>
void swap(T& a, T& b) noexcept {
   T c(std::move(a)); // move constructor
   a = std::move(b);  // move assignment
   b = std::move(c);  // move assignment
}

```


### Lecture 15: RAII and Smart Pointers

#### RALL
* All resources should be acquired in the constructor.
* All resources should be released in the destructor.


#### Examples
![](./images/4.png)
![](./images/5.png)
![](./images/6.png)


#### `std::unique_ptr`
* Uniquely owns its resource and deletes it when the object is destroyed
* Cannot be copied (but can be moved, if non-const!)

#### `std::shared_ptr`
* Resource can be stored by any number of `std::shared_ptrs`
* The resource is deleted when none of them points to it


```C++
std::unique_ptr<T> up{new T};
std::unique_ptr<T> up = std::make_unique<T>();
std::shared_ptr<T> sp{new T};
std::shared_ptr<T> sp = std::make_shared<T>();
std::weak_ptr<T> wp = sp;
//can only be copy/move constructed (or empty)!
```
